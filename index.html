<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Wood Structure Designer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #measurement {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            padding: 5px;
            background: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="measurement"></div>

    <!-- Three.js and controls from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/DragControls.js"></script>

    <script>
        // ----- Scene Setup -----
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x444444);

        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(50, 50, 50);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("canvas-container").appendChild(renderer.domElement);

        // ----- Controls -----
        const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        // Mouse buttons
        orbitControls.mouseButtons = {
            MIDDLE: THREE.MOUSE.PAN,
            // MIDDLE: THREE.MOUSE.DOLLY,
            SCROLL: THREE.MOUSE.DOLLY,
            // MIDDLE: THREE.MOUSE.PAN
        }

        // ----- Grid Helper (for reference) -----
        const gridHelper = new THREE.GridHelper(100, 100);
        scene.add(gridHelper);

        // ----- Lighting -----
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);

        // ----- Ground Plane (for raycasting when drawing) -----
        // We use a mathematical plane (y = 0) rather than a visible mesh.
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        // ----- Measurement Display -----
        const measurementDiv = document.getElementById("measurement");

        // ----- Group to hold all beams -----
        const beamsGroup = new THREE.Group();
        scene.add(beamsGroup);

        // ----- Drag Controls for beams -----
        // (They let you click and drag an existing beam.)

        class LeftClickDragControls extends THREE.DragControls {
            constructor(objects, camera, domElement) {
                super(objects, camera, domElement);

                this.onPointerDown = (event) => {
                    if (event.button === 0) { // Check for left mouse button
                        this.enabled = true;
                    } else {
                        this.enabled = false;
                        base.enabled = false;

                    }
                };
            }
        }
        const dragControls = new LeftClickDragControls(beamsGroup.children, camera, renderer.domElement);

        dragControls.addEventListener("dragstart", function (event) {
            if (event.button !== 0) return; // Only respond to left mouse button.
            orbitControls.enabled = false;
        });
        dragControls.addEventListener("dragend", function (event) {
            if (event.button !== 0) return; // Only respond to left mouse button.
            orbitControls.enabled = true;
            // Here you could update a measurement display if you want.
        });

        // ----- Variables for drawing beams -----
        let isDrawing = false;
        let startPoint = new THREE.Vector3();
        let previewLine = null;
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // Utility function to get the intersection point on the ground
        function getGroundIntersection(clientX, clientY) {
            pointer.x = (clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersection);
            return intersection;
        }

        // ----- Event Listeners for Drawing a Beam -----
        renderer.domElement.addEventListener("pointerdown", function (event) {
            if (event.button !== 0) return; // Only respond to left mouse button.

            // Check if we are clicking on an existing beam.
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(beamsGroup.children, true);
            if (intersects.length === 0) {
                // Start drawing a new beam.
                isDrawing = true;
                startPoint.copy(getGroundIntersection(event.clientX, event.clientY));

                // Create a red preview line (initially zero length)
                const geometry = new THREE.BufferGeometry().setFromPoints([startPoint, startPoint.clone()]);
                const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
                previewLine = new THREE.Line(geometry, material);
                scene.add(previewLine);
            }
        }, false);

        renderer.domElement.addEventListener("pointermove", function (event) {
            if (isDrawing && previewLine) {
                const currentPoint = getGroundIntersection(event.clientX, event.clientY);
                const points = [startPoint, currentPoint];
                previewLine.geometry.setFromPoints(points);
                const distance = startPoint.distanceTo(currentPoint);
                measurementDiv.innerText = "Current beam length: " + distance.toFixed(2) + " units";
            }
        }, false);

        renderer.domElement.addEventListener("pointerup", function (event) {
            if (isDrawing && previewLine) {
                const endPoint = getGroundIntersection(event.clientX, event.clientY);
                const distance = startPoint.distanceTo(endPoint);
                // Only create a beam if the length is significant
                if (distance > 0.1) {
                    // ----- Create the Beam -----
                    // For a typical 2x4, the cross-section is about 1.5" x 3.5"
                    const beamHeight = 1.5;
                    const beamDepth = 3.5;
                    // Create a box whose width equals the distance.
                    const geometry = new THREE.BoxGeometry(distance, beamHeight, beamDepth);
                    // Translate the geometry so that its local origin lies at the left (start) end.
                    geometry.translate(distance / 2, 0, 0);
                    const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const beam = new THREE.Mesh(geometry, material);

                    // Position the beam so that its left end is at startPoint.
                    beam.position.copy(startPoint);

                    // Compute the direction from startPoint to endPoint.
                    const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
                    // Create a quaternion that rotates the local X axis (1,0,0)
                    // so it aligns with the computed direction.
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
                    beam.quaternion.copy(quaternion);

                    // Add the beam to the scene.
                    beamsGroup.add(beam);
                }
                // Clean up the preview line and reset drawing state.
                scene.remove(previewLine);
                previewLine.geometry.dispose();
                previewLine.material.dispose();
                previewLine = null;
                isDrawing = false;
                measurementDiv.innerText = "";
            }
        }, false);

        // ----- Animation Loop -----
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // ----- Handle Window Resize -----
        window.addEventListener("resize", function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    </script>
</body>

</html>