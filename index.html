<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Wood Structure Designer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #measurement {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            padding: 5px;
            background: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="measurement"></div>
    <!-- Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ----- Scene Setup -----
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x444444);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 50, 50);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("canvas-container").appendChild(renderer.domElement);

        // ----- Controls -----
        const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        orbitControls.mouseButtons = { MIDDLE: THREE.MOUSE.PAN, SCROLL: THREE.MOUSE.DOLLY };

        // ----- Grid Helper -----
        const gridHelper = new THREE.GridHelper(100, 100);
        scene.add(gridHelper);

        // ----- Lighting -----
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);

        // ----- Ground Plane (for raycasting) -----
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        // ----- Measurement Display -----
        const measurementDiv = document.getElementById("measurement");

        // ----- Group to hold beams -----
        const beamsGroup = new THREE.Group();
        scene.add(beamsGroup);

        // --- Variables for Drag & Snapping ---
        let currentDraggedBeam = null; // The beam being dragged.
        let lastMouseEvent = null;
        // For anchoring the drag, store initial beam position, its face data, and the pointer ground intersection.
        let dragInitialBeamPos = new THREE.Vector3();
        // dragInitialFaceCenters will be an array of objects { faceType, center, normal } (in world space) captured at pointerdown.
        let dragInitialFaceCenters = [];
        let dragInitialPointer = new THREE.Vector3();

        // --- Variables for Drawing ---
        let isDrawing = false;
        let startPoint = new THREE.Vector3();
        let previewLine = null;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // Utility: Get ground intersection point.
        function getGroundIntersection(clientX, clientY) {
            pointer.x = (clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, intersection);
            return intersection;
        }

        // Helper: getBeamFaceCenters
        // Returns an array of objects { faceType, center, normal } in world space.
        function getBeamFaceCenters(beam) {
            const length = beam.userData.length;
            const height = beam.userData.height;
            const depth = beam.userData.depth;
            const localFaces = [
                { faceType: "left", pos: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(-1, 0, 0) },
                { faceType: "right", pos: new THREE.Vector3(length, 0, 0), normal: new THREE.Vector3(1, 0, 0) },
                { faceType: "top", pos: new THREE.Vector3(length / 2, height / 2, 0), normal: new THREE.Vector3(0, 1, 0) },
                { faceType: "bottom", pos: new THREE.Vector3(length / 2, -height / 2, 0), normal: new THREE.Vector3(0, -1, 0) },
                { faceType: "front", pos: new THREE.Vector3(length / 2, 0, depth / 2), normal: new THREE.Vector3(0, 0, 1) },
                { faceType: "back", pos: new THREE.Vector3(length / 2, 0, -depth / 2), normal: new THREE.Vector3(0, 0, -1) }
            ];
            const faces = [];
            localFaces.forEach(face => {
                const center = face.pos.clone();
                beam.localToWorld(center);
                const normal = face.normal.clone().applyQuaternion(beam.quaternion);
                faces.push({ faceType: face.faceType, center: center, normal: normal });
            });
            return faces;
        }

        // Helper: getFaceUnderCursor
        // Given a beam and a pointer event, returns the face (object with faceType, center, normal) whose plane is hit.
        function getFaceUnderCursor(beam, event) {
            const pointerVec = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(pointerVec, camera);
            const ray = raycaster.ray;
            const faces = getBeamFaceCenters(beam);
            const { length, height, depth } = beam.userData;
            let validFaces = [];
            faces.forEach(face => {
                // Create a plane for this face.
                const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(face.normal.clone().normalize(), face.center);
                const intersection = new THREE.Vector3();
                if (ray.intersectPlane(plane, intersection)) {
                    let localIntersection = intersection.clone();
                    beam.worldToLocal(localIntersection);
                    let inside = false;
                    switch (face.faceType) {
                        case "left":
                            if (Math.abs(localIntersection.x - 0) < 0.01 &&
                                localIntersection.y >= -height / 2 && localIntersection.y <= height / 2 &&
                                localIntersection.z >= -depth / 2 && localIntersection.z <= depth / 2)
                                inside = true;
                            break;
                        case "right":
                            if (Math.abs(localIntersection.x - length) < 0.01 &&
                                localIntersection.y >= -height / 2 && localIntersection.y <= height / 2 &&
                                localIntersection.z >= -depth / 2 && localIntersection.z <= depth / 2)
                                inside = true;
                            break;
                        case "top":
                            if (Math.abs(localIntersection.y - height / 2) < 0.01 &&
                                localIntersection.x >= 0 && localIntersection.x <= length &&
                                localIntersection.z >= -depth / 2 && localIntersection.z <= depth / 2)
                                inside = true;
                            break;
                        case "bottom":
                            if (Math.abs(localIntersection.y + height / 2) < 0.01 &&
                                localIntersection.x >= 0 && localIntersection.x <= length &&
                                localIntersection.z >= -depth / 2 && localIntersection.z <= depth / 2)
                                inside = true;
                            break;
                        case "front":
                            if (Math.abs(localIntersection.z - depth / 2) < 0.01 &&
                                localIntersection.x >= 0 && localIntersection.x <= length &&
                                localIntersection.y >= -height / 2 && localIntersection.y <= height / 2)
                                inside = true;
                            break;
                        case "back":
                            if (Math.abs(localIntersection.z + depth / 2) < 0.01 &&
                                localIntersection.x >= 0 && localIntersection.x <= length &&
                                localIntersection.y >= -height / 2 && localIntersection.y <= height / 2)
                                inside = true;
                            break;
                    }
                    if (inside) {
                        const dist = intersection.distanceTo(camera.position);
                        validFaces.push({ face: face, intersection: intersection, distance: dist });
                    }
                }
            });
            if (validFaces.length > 0) {
                validFaces.sort((a, b) => a.distance - b.distance);
                return validFaces[0].face;
            }
            return null;
        }

        // Helper: snapDirection – snaps a vector to one of the six cardinal axes.
        function snapDirection(direction) {
            const axes = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, -1, 0),
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -1)
            ];
            let bestAxis = axes[0];
            let bestDot = -Infinity;
            axes.forEach(ax => {
                const dot = direction.dot(ax);
                if (dot > bestDot) {
                    bestDot = dot;
                    bestAxis = ax;
                }
            });
            return bestAxis;
        }

        // Keydown: Cycle active snap face for dragged beam.
        window.addEventListener("keydown", function (event) {
            if (event.key.toLowerCase() === 'f' && currentDraggedBeam) {
                activeSnapFaceIndex = (activeSnapFaceIndex + 1) % 6;
                console.log("Active snap face index:", activeSnapFaceIndex);
            }
        });

        // ----- Custom Drag & Drawing Handlers -----
        window.addEventListener("pointerdown", function (event) {
            if (event.button !== 0) return;
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(beamsGroup.children, true);
            if (intersects.length > 0) {
                currentDraggedBeam = intersects[0].object;
                dragInitialBeamPos.copy(currentDraggedBeam.position);
                // Store initial face data.
                dragInitialFaceCenters = getBeamFaceCenters(currentDraggedBeam).map(face => {
                    return { faceType: face.faceType, center: face.center.clone(), normal: face.normal.clone() };
                });
                dragInitialPointer.copy(getGroundIntersection(event.clientX, event.clientY));
            } else {
                isDrawing = true;
                startPoint.copy(getGroundIntersection(event.clientX, event.clientY));
                const geometry = new THREE.BufferGeometry().setFromPoints([startPoint, startPoint.clone()]);
                const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
                previewLine = new THREE.Line(geometry, material);
                scene.add(previewLine);
            }
        });

        window.addEventListener("pointermove", function (event) {
            lastMouseEvent = event;
            if (currentDraggedBeam) {
                const currentPointer = getGroundIntersection(event.clientX, event.clientY);
                const delta = new THREE.Vector3().subVectors(currentPointer, dragInitialPointer);
                const freeCandidate = new THREE.Vector3().addVectors(dragInitialBeamPos, delta);

                // Temporarily remove dragged beam for raycasting.
                beamsGroup.remove(currentDraggedBeam);
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(pointer, camera);
                const intersections = raycaster.intersectObjects(beamsGroup.children, true);
                let targetBeam = null, targetIntersection = null;
                for (let inter of intersections) {
                    targetBeam = inter.object;
                    targetIntersection = inter.point;
                    break;
                }
                beamsGroup.add(currentDraggedBeam);

                let finalPos = freeCandidate.clone();
                if (targetBeam && targetIntersection) {
                    // Use getFaceUnderCursor to lock in the target face.
                    const targetFace = getFaceUnderCursor(targetBeam, event);
                    if (targetFace && targetFace.center) {
                        // Instead of matching the same face, choose the dragged face that best aligns with the OPPOSITE of the target face's normal.
                        let bestCandidateFace = null;
                        let bestDot = -Infinity;
                        const oppositeNormal = targetFace.normal.clone().negate();
                        dragInitialFaceCenters.forEach(face => {
                            const dot = face.normal.dot(oppositeNormal);
                            if (dot > bestDot) {
                                bestDot = dot;
                                bestCandidateFace = face;
                            }
                        });
                        if (bestCandidateFace) {
                            // Compute where the dragged beam’s candidate face would be if the beam were at freeCandidate.
                            const candidateDraggedFace = bestCandidateFace.center.clone().add(
                                freeCandidate.clone().sub(dragInitialBeamPos)
                            );
                            // Compute the difference vector between target face center and candidate dragged face.
                            const d = new THREE.Vector3().subVectors(targetFace.center, candidateDraggedFace);
                            // Project this difference onto the target face’s normal.
                            const adjustment = targetFace.normal.clone().multiplyScalar(d.dot(targetFace.normal));
                            finalPos.add(adjustment);
                        }
                    }
                }

                currentDraggedBeam.position.copy(finalPos);
                currentDraggedBeam.updateMatrixWorld();
            }
            if (isDrawing && previewLine) {
                const currentPoint = getGroundIntersection(event.clientX, event.clientY);
                previewLine.geometry.setFromPoints([startPoint, currentPoint]);
                const distance = startPoint.distanceTo(currentPoint);
                measurementDiv.innerText = "Current beam length: " + distance.toFixed(2) + " units";
            }
        });

        window.addEventListener("pointerup", function (event) {
            if (currentDraggedBeam) {
                currentDraggedBeam = null;
                dragInitialBeamPos.set(0, 0, 0);
                dragInitialFaceCenters = [];
                dragInitialPointer.set(0, 0, 0);
            }
            if (isDrawing && previewLine) {
                const endPoint = getGroundIntersection(event.clientX, event.clientY);
                const distance = startPoint.distanceTo(endPoint);
                if (distance > 0.1) {
                    const beamHeight = 1.5;
                    const beamDepth = 3.5;
                    const geometry = new THREE.BoxGeometry(distance, beamHeight, beamDepth);
                    geometry.translate(distance / 2, 0, 0);
                    const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const beam = new THREE.Mesh(geometry, material);
                    beam.userData = { length: distance, height: beamHeight, depth: beamDepth };
                    beam.position.copy(startPoint);
                    const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
                    const snappedDir = snapDirection(direction);
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), snappedDir);
                    beam.quaternion.copy(quaternion);
                    beamsGroup.add(beam);
                }
                scene.remove(previewLine);
                previewLine.geometry.dispose();
                previewLine.material.dispose();
                previewLine = null;
                isDrawing = false;
                measurementDiv.innerText = "";
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener("resize", function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    </script>
</body>

</html>